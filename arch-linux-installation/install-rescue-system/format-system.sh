#!/bin/bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([device],[d],[Device that will be formatted],[/dev/sda])
# ARG_OPTIONAL_SINGLE([size],[s],[Size of boot/rescue partition],[5])
# ARG_OPTIONAL_SINGLE([mount],[m],[Directory that will be used to mount devices and images],[/mnt])
# ARG_OPTIONAL_SINGLE([image],[i],[Image with pre-system content],[~/pre-system.sfs])
# ARGBASH_SET_DELIM([ ])
# ARG_OPTION_STACKING([none])
# ARG_RESTRICT_VALUES([none])
# ARG_HELP([This script format and install a minimal system on the device to be able to install GRUB and rescue system])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_device="/dev/sda"
_arg_size="5"
_arg_mount="/mnt"
_arg_image="~/pre-system.sfs"


print_help()
{
	printf '%s\n' "This script format and install a minimal system on the device to be able to install GRUB and rescue system"
	printf 'Usage: %s [-d|--device <arg>] [-s|--size <arg>] [-m|--mount <arg>] [-i|--image <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-d, --device: Device that will be formatted (default: '/dev/sda')"
	printf '\t%s\n' "-s, --size: Size of boot/rescue partition (default: '5')"
	printf '\t%s\n' "-m, --mount: Directory that will be used to mount devices and images (default: '/mnt')"
	printf '\t%s\n' "-i, --image: Image with pre-system content (default: '~/pre-system.sfs')"
	printf '\t%s\n' "-h, --help: Prints help"
	echo
	echo 'Short options stacking mode is not supported.'
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--device)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_device="$2"
				shift
				;;
			-s|--size)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_size="$2"
				shift
				;;
			-m|--mount)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_mount="$2"
				shift
				;;
			-i|--image)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_image="$2"
				shift
				;;
			-h|--help)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

define_vars()
{
	main_device="$1"
	partition_size="$2"
	mount_point="$3"
	squashfs_file="$4"
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv
cat << EOF
This script will format the device $_arg_device as follows:
	A first partition with $_arg_size GiB, where Grub and rescue system will be installed later
	A second partition using the remaining space left where the "pre-system" will be installed

This pre-system is used to install Grub and make the system bootable and, after that,
will install the rescue system (copy the ISO file and create the rescue system option on Grub)

All partitions/images that need to be mounted will be mounted bellow $_arg_mount directory.
This script will create 2 directories:
	$_arg_mount/presystem
	$_arg_mount/boot

The image used on the pre-system installation is this: $_arg_image.

This script is about to format the device $_arg_device and will ERASE EVERYTHING.
ARE YOU SURE YOU WANT TO CONTINUE? <y/N>
EOF

read -r answer
case "$answer" in
	y|Y)
		echo "Starting script";;
	*)
        echo "Exited script"
		exit;;
esac

define_vars "$_arg_device" "$_arg_size" "$_arg_mount" "$_arg_image"

if [[ -z $main_device || -z $partition_size || -z $mount_point || -z $squashfs_file  ]]
then
    echo "You need to pass values to all flags"
fi

device_type="$(echo "$main_device" | cut -b '6-9')"

if [ "$device_type" = "loop" ]; then
    main_device_parts="$main_device"p
else
    main_device_parts="$main_device"
fi

mounted_folder=$(mount | grep "$main_device_parts"2 | awk '{ print $3 }')
if [ -n "$mounted_folder" ]; then
    sudo umount -R "$mounted_folder"
fi

squash_device=$(losetup | grep "$squashfs_file" | awk '{ print $1 }')
if [ -n "$squash_device" ]; then
    mounted_squash=$(mount | grep "$squash_device" | awk '{ print $3 }')
    if [ -n "$mounted_squash" ]; then
        sudo umount -R "$mounted_squash"
    fi
fi

sudo parted -sa optimal -- "$main_device" \
mklabel gpt \
mkpart boot fat32 0% "$partition_size"GiB set 1 boot on \
mkpart mini ext4 "$partition_size"GiB -1 \
print

sudo mkfs.fat -F32 "$main_device_parts"1
sudo mkfs.ext4 "$main_device_parts"2

presystem_dir="$mount_point/pre-system"

if [ ! -d "$presystem_dir" ]; then
    sudo mkdir "$presystem_dir"
fi

sudo mount "$main_device_parts"2 "$presystem_dir"

if [ -n "$squash_device" ]; then
    presystem_device="$squash_device"
else
    presystem_device=$(sudo losetup -fP --show "$squashfs_file")
fi

squash_dir="$mount_point"/squashfs
if [ ! -d "$squash_dir" ]; then
    sudo mkdir "$squash_dir"
fi

sudo mount "$presystem_device" "$squash_dir"

sudo rsync -ahS --info=progress2 "$squash_dir"/ "$presystem_dir"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
